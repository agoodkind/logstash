filter {
    if [type] == "syslog" and [process][name] == "unbound" {
        mutate {
            add_field => {
                "log_type" => "unbound"
            }
        }

        grok {
            match => {
                "message" => [
                "\[%{INT:unbound_pid}:%{INT:unbound_thread}\] %{LOGLEVEL:log_level}: query response was %{WORD:response_type} %{WORD:response_section}",
                "\[%{INT:unbound_pid}:%{INT:unbound_thread}\] %{LOGLEVEL:log_level}: reply from %{DATA:reply_zone} %{IPORHOST:reply_server}#%{INT:reply_port}",
                "\[%{INT:unbound_pid}:%{INT:unbound_thread}\] %{LOGLEVEL:log_level}: Verified that unsigned response is %{WORD:dnssec_status}",
                "\[%{INT:unbound_pid}:%{INT:unbound_thread}\] %{LOGLEVEL:log_level}: iterator operate: query %{DATA:query_name}\. %{WORD:query_type} %{WORD:query_class}",
                "\[%{INT:unbound_pid}:%{INT:unbound_thread}\] %{LOGLEVEL:log_level}: %{GREEDYDATA:log_message}"
                ]
            }
        }

        if [reply_server] {
            mutate {
                copy => {
                    "reply_server" => "reply_server_hostname"
                }
            }
            dns {
                reverse => ["reply_server_hostname"]
                action => "append"
                hit_cache_size => 4096
                hit_cache_ttl => 300
                failed_cache_size => 2048
                failed_cache_ttl => 60
                timeout => 2
                max_retries => 1
            }
        }

        mutate {
            remove_field => ["message"]
            remove_tag => ["_grokparsefailure"]
        }
    }
}
