filter {
    if [type] == "syslog" and [process][name] == "filterlog" {
        mutate {
            add_field => {
                "log_type" => "filterlog"
                "[data_stream][type]" => "logs"
                "[data_stream][dataset]" => "filterlog"
                "[data_stream][namespace]" => "opnsense"
                "service" => "filterlog"
            }
        }

        ruby {
            path => "/etc/logstash/ruby/parse_filterlog.rb"
        }

        # Correctly type fields
        mutate {
            convert => {
                "rulenr" => "integer"
                "ttl" => "integer"
                "id" => "integer"
                "offset" => "integer"
                "protonum" => "integer"
                "length" => "integer"
                "srcport" => "integer"
                "dstport" => "integer"
                "datalen" => "integer"
                "window" => "integer"
                "seq" => "string"
            }
            strip => ["src", "dst", "action", "dir", "protoname", "interface", "reason", "tcpflags", "label"]
        }

        # Reverse DNS lookup for src (IPv4 and IPv6)
        if [src] {
            mutate {
                copy => {
                    "src" => "src_hostname"
                }
            }
            dns {
                reverse => ["src_hostname"]
                action => "replace"
                hit_cache_size => 4096
                hit_cache_ttl => 300
                failed_cache_size => 2048
                failed_cache_ttl => 60
                timeout => 1
                max_retries => 0
            }
        }

        # Reverse DNS lookup for dst (IPv4 and IPv6)
        if [dst] {
            mutate {
                copy => {
                    "dst" => "dst_hostname"
                }
            }
            dns {
                reverse => ["dst_hostname"]
                action => "replace"
                hit_cache_size => 4096
                hit_cache_ttl => 300
                failed_cache_size => 2048
                failed_cache_ttl => 60
                timeout => 1
                max_retries => 0
            }
        }

        # GeoIP enrichment for IPv4 source addresses (skip private ranges)
        if [src] and [src] =~ /^([0-9]{1,3}\.){3}[0-9]{1,3}$/ {
            if [src] !~ /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.|127\.|169\.254\.)/ {
                geoip {
                    source => "src"
                    target => "src_geoip"
                }
            }
        }

        # GeoIP enrichment for IPv4 destination addresses (skip private ranges)
        if [dst] and [dst] =~ /^([0-9]{1,3}\.){3}[0-9]{1,3}$/ {
            if [dst] !~ /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.|127\.|169\.254\.)/ {
                geoip {
                    source => "dst"
                    target => "dst_geoip"
                }
            }
        }

        # Final cleanup and field management
        mutate {
            copy => {
                "interface" => "interface_name"
            }
            rename => {
                "label" => "rid"
            }
            remove_tag => ["_geoip_lookup_failure"]
        }

        # After parsing, remove the raw message to save space
        mutate {
            remove_field => ["syslog_message", "message"]
        }
    }
}
